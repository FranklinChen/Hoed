\subsection{
\label{compilerprac}
About Imp (in the {\tt Compiler} directory)}

The final group of exercises involve testing, tracing, fixing, specifying
and extending the Imp interpreter and compiler.

\paragraph{\nextex}
Recall the \QuickCheck{} congruence property
that should hold for the Imp compiler and the interpreter.
The version of the Imp system in the {\tt Compiler} directory
has been deliberately broken, so it does not satisfy this
property.  Indeed, it hardly works at all: try running it
on {\tt gcd.in}.
Use \QuickCheck{} and \Hat{} to find the two bugs we have introduced.
Fix them!
\hfill$\Box$

\paragraph{\nextex}
There are some functions in which we can apparently introduce as
many bugs as we want; the congruence property will still hold!
Which are these functions?
{\bf Hint:} Which functions are used both by the compiler and the
interpreter?
\hfill$\Box$

\paragraph{\nextex}
Random testing works best if it is applied at a fine grain! Therefore,
formulate a property that is only going to test
compilation and interpretation of
{\em expressions}.
{\bf Hint:} You can reuse the congruence property of programs, but generate
only programs that print a single expression (which cannot contain variables).
Is non-termination still an issue?
% Non-termination is not an issue as a {\tt print} statement always
% terminates.
\hfill$\Box$

\paragraph{\nextex}
Now investigate the test coverage of \QuickCheck{} for
your property. Insert a test data monitor that checks what kind of traces are
generated by the programs during test, and check the distribution.
What do you think of the distribution of
test data? Most generated expressions are type
incorrect! Adapt your property by using the implication operator {\tt ==>} to
discard this rather large amount of useless test data.

{\bf Note:} To show that without this fix, your property does not have good test
coverage, introduce the following bug: flip the order of the arguments of
binary operators in the expression compiler. Can your old property find the
bug? Can your new one?
\hfill$\Box$

\paragraph{\nextex}
The original congruence property for programs
has a similar problem; the whole program crashes if the condition in an {\tt
if} or {\tt while} statement is type incorrect, and this happens a lot during
testing. Adapt the program congruence property to overcome this problem.
\hfill$\Box$

\paragraph{\nextex}
Suppose the Imp language is extended by generalising assignments to
multiple assignments.  Instead of just one variable name on the left of
each {\tt :=} there are one or more, separated by commas, and on the right
an equal number of expressions, also separated by commas.
A multiple assignment is executed by first evaluating all the right-hand
expressions and then storing the results in corresponding left-hand
variables in left-to-right order.
Here is an example program ({\tt power.in}) which raises {\tt 3} to the
power {\tt 6}:
\begin{verbatim}
a, n, x := 3, 6, 1;
while 0 < n do
  if (n\2) = 1 then n, x := n-1, x*a else skip fi;
  a, n := a*a, n/2
od;
print x
\end{verbatim}
By making changes in the following places,
revise the Imp interpreter and compiler to work with
multiple assignments.
\begin{center}
\renewcommand{\arraystretch}{2.0}
\begin{tabular}{ll}
{\tt Syntax}   &
  \parbox[t]{3.5in}{Change the {\tt :=} construction in the {\tt Command} type.} \\
{\tt Parser}   &
  \parbox[t]{3.5in}{Change the final alternative in {\tt nonSeqCommand}. \\
     {\bf Hint:} define
     {\tt listOf :: Parser a -> Parser [a]}. } \\
{\tt Interpreter} & 
  \parbox[t]{3.5in}{Change the {\tt :=} equation in
                    the definition of {\tt run}. \\
     {\bf Hint:} generalise the definition of {\tt update}.} \\
{\tt StackMap} &
  \parbox[t]{3.5in}{Change the {\tt :=} equation in
                    the definition of {\tt comVars}.} \\
{\tt Compiler} &
  \parbox[t]{3.5in}{Change the {\tt :=} equation in the
                    definition of {\tt compObey}. \\
          {\bf Hint:} none --- we hope you get it wrong!}
\end{tabular}
\renewcommand{\arraystretch}{1.0}
\end{center}
Test your extension first on {\tt power.in}, using \Hat{} to
investigate any faults.
% When you have an interpreter and compiler that work for this example
% program do you suppose it will work for all parallel-assignment programs?
Revise the program generator in the {\tt Properties.hs} so that the congruence
property is asserted over the extended language.  Apply \QuickCheck{} and
\Hat{} as necessary to achieve a solution that passes an appropriate range
of tests.
\hfill$\Box$

\paragraph{\nextex}
Compare the assignments:
\begin{alltt}
x, y := e1, e2         and          y, x := e2, e1
\end{alltt}
Under what conditions do these two assignments mean the same thing?
Formulate this conditional equivalence
as a \QuickCheck{} property and check that the property holds.
\hfill$\Box$
